# **สถาปัตยกรรมระบบ Web Application หลายภาษา (CMS-like)**

เอกสารฉบับนี้มีวัตถุประสงค์เพื่อนำเสนอภาพรวมเชิงสถาปัตยกรรมของ Web Application ซึ่งกำลังอยู่ระหว่างการออกแบบและพัฒนา ระบบดังกล่าวได้รับการออกแบบให้ทำหน้าที่เป็นระบบจัดการเนื้อหา (CMS-like) ที่มีความสามารถในการรองรับหลายภาษาอย่างครบวงจร โดยให้ความสำคัญสูงสุดกับการนำส่วนประกอบกลับมาใช้ซ้ำได้ (reusability) ความยืดหยุ่น และขีดความสามารถในการปรับขนาดระบบ (scalability) สำหรับการขยายขีดความสามารถในอนาคตอันใกล้ สถาปัตยกรรมที่นำเสนอจะช่วยให้องค์กรสามารถบริหารจัดการและเผยแพร่เนื้อหาผลิตภัณฑ์ได้อย่างมีประสิทธิภาพในบริบทของตลาดที่มีความหลากหลายทางภาษา พร้อมทั้งวางรากฐานที่มั่นคงสำหรับการต่อยอดฟังก์ชันการทำงานในระยะยาว

## 1. วัตถุประสงค์ของโครงการ

โครงการนี้มุ่งพัฒนาเว็บแอปพลิเคชันที่มีลักษณะคล้ายระบบจัดการเนื้อหา (CMS) โดยรองรับการทำงานหลายภาษา เพื่อสนับสนุนการเผยแพร่เชิงพาณิชย์ของผลิตภัณฑ์ "พริกไทยตรัง" ระบบได้รับการออกแบบให้สามารถปรับขยายและนำกลับมาใช้ซ้ำได้ อีกทั้งยังสอดคล้องกับแนวทางการทำ Internationalization (i18n) และ Localization (l10n) ทั้งในส่วนของส่วนติดต่อผู้ใช้และโครงสร้างข้อมูลที่จัดเก็บ โดยระบบนี้จะใช้ Next.js ร่วมกับ PostgreSQL แทนการใช้ CMS สำเร็จรูป เพื่อให้เกิดความยืดหยุ่นในระดับโครงสร้าง

## 2. โครงสร้างพื้นฐานของระบบ (Core Stack)

ระบบนี้จะถูกพัฒนาภายใต้โครงสร้าง Full-stack JavaScript/TypeScript ซึ่งมีส่วนประกอบหลักดังต่อไปนี้:

- **ภาษาโปรแกรม:** **TypeScript** (พร้อม Strict Mode) การนำ TypeScript มาใช้งานในโหมด Strict Mode ช่วยเสริมสร้างความมั่นคงด้าน Type Safety ในระดับสูง ซึ่งส่งผลให้สามารถตรวจจับข้อผิดพลาดที่เกี่ยวข้องกับชนิดข้อมูลได้ตั้งแต่ขั้นตอนการพัฒนา (compile-time) ก่อให้เกิดความแข็งแกร่งของรหัสโปรแกรม ลดโอกาสการเกิดข้อผิดพลาดขณะทำงาน (runtime errors) และอำนวยความสะดวกอย่างยิ่งต่อกระบวนการบำรุงรักษาในระยะยาว นอกจากนี้ยังช่วยให้การพัฒนาขนาดใหญ่ (large-scale development) มีความคล่องตัวขึ้น เนื่องจากโครงสร้างโค้ดที่ชัดเจนและเอกสารที่สร้างขึ้นโดยอัตโนมัติ (self-documenting code)
- **เฟรมเวิร์ก:** **Next.js** (ใช้ **App Router** เป็นหลัก)
  - **Frontend:** ในส่วนของ **Frontend** มีการใช้ Next.js เพื่อสร้างส่วนติดต่อผู้ใช้ (User Interface) โดยอาศัย React Components ซึ่งรองรับทั้ง Server Components และ Client Components การผสานรวมคุณสมบัติเหล่านี้ช่วยเสริมประสิทธิภาพในการเรนเดอร์ข้อมูล (เช่น การลดปริมาณ JavaScript ที่ส่งไปยัง Client-side) และการทำ SEO ที่ดีเยี่ยม ทำให้เว็บไซต์สามารถถูกค้นพบได้ง่ายโดย Search Engines และมอบประสบการณ์ผู้ใช้ที่รวดเร็วและตอบสนองได้ดี
  - **Backend:** สำหรับส่วนของ **Backend** มีการใช้ Next.js **Route Handlers** ซึ่งเป็นส่วนหนึ่งของ App Router เพื่อสร้าง API Endpoints สำหรับการจัดการ Logic ทางธุรกิจและการเชื่อมต่อฐานข้อมูล การออกแบบนี้มีส่วนช่วยลดการสลับบริบทในการพัฒนา (context switching) ระหว่าง Frontend และ Backend เนื่องจากสามารถใช้ภาษาและโครงสร้างโค้ดเดียวกันได้ ส่งผลให้กระบวนการพัฒนามีประสิทธิภาพยิ่งขึ้นและลดความซับซ้อนในการจัดการ Deployment

- **ฐานข้อมูล:** **PostgreSQL**
  - **ผู้ให้บริการ:** Supabase (เลือกใช้บริการ Cloud PostgreSQL)
  - **เหตุผล:** การเลือกใช้ PostgreSQL เป็นฐานข้อมูลหลักมีสาเหตุมาจากคุณสมบัติที่เป็น Relational Database ที่มีประสิทธิภาพสูงและเชื่อถือได้ ซึ่งเหมาะสมอย่างยิ่งสำหรับการจัดการข้อมูลที่มีความสัมพันธ์กันและต้องการความถูกต้องแม่นยำของข้อมูล (ACID compliance) นอกจากนี้ยังรองรับ **JSONB data type** ได้อย่างยอดเยี่ยม ซึ่งเป็นกุญแจสำคัญในการจัดเก็บข้อมูลหลายภาษา (Localization, l10n) ใน Field เดียวกันได้อย่างยืดหยุ่น และเอื้อต่อการสืบค้นข้อมูลภายในโครงสร้าง JSON ได้อย่างมีประสิทธิภาพผ่าน Indexing และ Query Functions ของ PostgreSQL ทำให้ไม่ต้องสร้างคอลัมน์แยกต่างหากสำหรับทุกภาษา
  - **ORM (Object-Relational Mapper):** **Prisma** ได้รับการเลือกใช้เป็น Object-Relational Mapper (ORM) เพื่ออำนวยความสะดวกในการเชื่อมต่อและการจัดการฐานข้อมูล PostgreSQL การใช้ Prisma ช่วยให้การทำงานกับฐานข้อมูลมีความปลอดภัยด้าน Type (Type Safe) ผ่านการสร้าง Prisma Client ที่มีการตรวจสอบชนิดข้อมูลอัตโนมัติ (autocompletion) และลดความซับซ้อนของการเขียน SQL Queries โดยตรง นอกจากนี้ Prisma ยังมาพร้อมกับระบบ Migration ที่ช่วยในการบริหารจัดการการเปลี่ยนแปลง Schema ของฐานข้อมูลอย่างเป็นระบบ

- **ระบบยืนยันตัวตน (Authentication):** **NextAuth.js (Auth.js)**
  - **เหตุผล:** **NextAuth.js (Auth.js)** คือ Library ที่ได้รับการออกแบบมาโดยเฉพาะสำหรับ Next.js เพื่อจัดการกระบวนการยืนยันตัวตน (Authentication) และการจัดการ Session อย่างครอบคลุม โดยรองรับ Providers หลากหลายรูปแบบ (เช่น Credentials, OAuth providers) และสามารถเชื่อมต่อกับฐานข้อมูลผ่าน Prisma Adapter ได้อย่างราบรื่น ช่วยลดภาระในการพัฒนาระบบยืนยันตัวตนที่ซับซ้อนและเสริมสร้างความปลอดภัยด้วยมาตรฐานอุตสาหกรรม
- **ระบบจัดการสิทธิ์ (Authorization):** **Role-Based Access Control (RBAC) Custom Implementation**
  - **เหตุผล:** เพื่อให้ระบบมีความยืดหยุ่นในการกำหนดสิทธิ์การเข้าถึงข้อมูลและฟังก์ชันการทำงานต่างๆ สำหรับผู้ดูแลระบบในระดับที่แตกต่างกัน จึงมีการสร้าง Schema และ Logic การตรวจสอบสิทธิ์ขึ้นเองใน Application Layer การออกแบบ RBAC ที่ปรับแต่งเองนี้ช่วยให้สามารถบริหารจัดการการอนุญาตได้อย่างละเอียด สามารถกำหนดบทบาท (Roles) และสิทธิ์ (Permissions) ที่ซับซ้อนได้ตามความต้องการทางธุรกิจที่เปลี่ยนแปลงไป โดยไม่จำเป็นต้องพึ่งพาระบบสำเร็จรูปที่มีข้อจำกัด

## 3. ภาพรวมของสถาปัตยกรรมระบบ

ระบบแบ่งออกเป็น 2 ส่วนหลัก:

- **ส่วนผู้ใช้งานทั่วไป (Public-facing):** ส่วนผู้ใช้งานทั่วไป (Public-facing) จะแสดงรายการสินค้า บทความ และแกลเลอรี่ในรูปแบบหลายภาษาผ่านเส้นทางแบบ dynamic (เช่น `/products`, `/blog`) โดยมุ่งเน้นประสิทธิภาพในการโหลดข้อมูลที่รวดเร็ว การแสดงผลที่ตอบสนองต่อผู้ใช้งาน (responsive rendering) และประสบการณ์การใช้งานที่ราบรื่นสำหรับผู้ใช้ปลายทาง เพื่อให้มั่นใจว่าเนื้อหาเข้าถึงได้ง่ายและน่าดึงดูดใจ
- **แดชบอร์ดผู้ดูแลระบบ (Admin Panel):** แดชบอร์ดผู้ดูแลระบบ (Admin Panel) มีไว้สำหรับผู้ใช้งานที่มีบทบาทเฉพาะเจาะจง เพื่อดำเนินการจัดการข้อมูล เนื้อหา และเมตาดาต้าต่างๆ พร้อมระบบแปลภาษาที่สามารถปรับตามภาษาที่ผู้ดูแลระบบเลือกใช้งาน ซึ่งส่วนนี้ให้ความสำคัญกับความปลอดภัย การควบคุมสิทธิ์การเข้าถึง และความสะดวกในการบริหารจัดการเนื้อหาและ Asset ต่างๆ อย่างมีประสิทธิภาพและเป็นระบบ

การกำหนดขอบเขตที่ชัดเจนระหว่างสองส่วนนี้ช่วยให้สามารถพัฒนาและบำรุงรักษาแต่ละส่วนได้อย่างอิสระ โดยมี API Endpoints ที่ทำหน้าที่เป็นจุดเชื่อมต่อที่มีการควบคุมอย่างเข้มงวด

## 4. การจัดการข้อมูลหลายภาษา (Internationalization - i18n & Localization - l10n)

ระบบได้รับการออกแบบให้รองรับการแสดงผลและการจัดการข้อมูลหลายภาษาอย่างครอบคลุม ซึ่งประกอบด้วยส่วนสำคัญดังนี้:

- **Localization (l10n) ในฐานข้อมูล:**
  - **แนวคิด:** ข้อมูลที่จำเป็นต้องมีการแปล (อาทิ ชื่อสินค้า, คำอธิบายผลิตภัณฑ์, หัวข้อบทความข่าวสาร) จะถูกจัดเก็บไว้ใน Field เดียวกันโดยใช้ **`JSONB` data type ของ PostgreSQL** การใช้วิธีการนี้ช่วยให้การจัดเก็บข้อมูลมีความยืดหยุ่นสูง สามารถเพิ่มภาษาใหม่ได้โดยไม่ต้องเปลี่ยนแปลงโครงสร้างตารางหลัก และยังคงประสิทธิภาพในการสืบค้นข้อมูลในแต่ละภาษาได้ดี
  - **โครงสร้างข้อมูล:** โครงสร้างข้อมูลจะถูกกำหนดโดยใช้ Type `LocalizedString` ใน TypeScript (ตัวอย่างเช่น `type LocalizedString = { [key: string]: string; }`) เพื่อใช้เป็นมาตรฐานในการจัดเก็บและส่งผ่านข้อมูลระหว่างส่วน Frontend และ Backend ซึ่งช่วยให้มั่นใจในความสอดคล้องของข้อมูลตลอดทั้งระบบ
  - **การป้อนข้อมูลใน Admin UI:** ในส่วนการป้อนข้อมูลผ่าน Admin UI ผู้ดูแลระบบจะมีความสามารถในการเลือกภาษาที่ต้องการกรอกข้อมูลสำหรับ Field ที่เป็น `LocalizedString` (เช่น การมี Tab หรือ Dropdown ให้เลือกภาษา) ซึ่งจะส่งผลให้มีการปรับปรุงค่าภายใน `LocalizedString` ของ Field นั้นๆ โดยข้อมูลในภาษาอื่นๆ ที่มีอยู่แล้วจะยังคงถูกเก็บรักษาไว้โดยไม่มีการลบ ทำให้การจัดการเนื้อหาหลายภาษามีความสะดวกและไม่เกิดการสูญหายของข้อมูล

- **Internationalization (i18n) ใน Frontend:**
  - **Routing:** Next.js จะจัดการ Internationalized Routing (ตัวอย่างเช่น `/en/products`, `/th/products`) เพื่อให้ URL สะท้อนภาษาที่ผู้ใช้งานเลือก ซึ่งเป็นมาตรฐานในการนำทางสำหรับเว็บไซต์หลายภาษา และเอื้อต่อการทำ SEO สำหรับเนื้อหาในแต่ละภาษา
- **Library:** ใช้ **`next-intl`** เป็น Library หลักสำหรับการจัดการ Static Text และ Routing ซึ่งเป็น Library ที่ออกแบบมาสำหรับ Next.js App Router โดยเฉพาะ ทำให้การจัดการเป็นไปอย่างเรียบง่ายและมีประสิทธิภาพ
- **Routing:** `next-intl` จัดการ Internationalized Routing ผ่าน Middleware (`src/middleware.ts`) และมีการดึงข้อความ (messages) สำหรับแต่ละภาษาจากไฟล์ JSON ในโฟลเดอร์ `messages/`
- **การใช้งาน:**
  - ใน Server Components, ใช้ `getTranslations`
  - ใน Client Components, ใช้ `useTranslations` hook
- **การจัดการภาษาใน Admin:** รายการภาษาที่รองรับจะถูกจัดเก็บในฐานข้อมูล (ในตาราง `languages` พร้อม `is_active` flag) ทำให้ผู้ดูแลระบบสามารถเพิ่ม, ลบ, หรือเปิด/ปิดการใช้งานภาษาผ่านหน้า Admin UI ได้อย่างยืดหยุ่นและเป็นระบบ การเปลี่ยนแปลงสถานะภาษาใน Admin UI จะส่งผลต่อภาษาที่แสดงผลบน Frontend Public Site ทำให้มีความสามารถในการควบคุมภาษาที่พร้อมใช้งานสำหรับผู้ใช้งานปลายทาง

## 5. ระบบจัดการไฟล์และสื่อภาพ (Media Asset Management)

ระบบนี้ได้รับการออกแบบมาเพื่อจัดการ Asset ประเภทรูปภาพและสื่ออื่นๆ อย่างเป็นระบบ เพื่อรองรับการใช้งานที่หลากหลายและมีประสิทธิภาพสูง:

- **โครงสร้าง Database:** ระบบกำหนดให้มีตาราง **`media`** สำหรับจัดเก็บข้อมูล Metadata ของรูปภาพ ซึ่งประกอบด้วยข้อมูลพื้นฐาน (อาทิ ชื่อไฟล์, ชนิดไฟล์, ขนาดไฟล์, URL ต้นฉบับ, ขนาดภาพ) และข้อมูลที่รองรับหลายภาษา (Alt Text, คำบรรยายภาพ ซึ่งใช้ `LocalizedString` โดยจัดเก็บในรูปแบบ JSONB เพื่อความยืดหยุ่นในการเพิ่มภาษาในอนาคต) นอกจากนี้ เพื่อสนับสนุนการแสดงผลที่เหมาะสมกับอุปกรณ์หลากหลายประเภทและบริบทการใช้งานที่แตกต่างกัน ระบบยังจัดเก็บ URL ของรูปภาพในขนาดต่างๆ (variants เช่น Thumbnail, Normal, Large) ใน Field `variants` ซึ่งเป็นประเภทข้อมูล JSONB ช่วยให้สามารถให้บริการภาพที่มีขนาดและคุณภาพเหมาะสมกับอุปกรณ์ของผู้ใช้งานได้โดยตรง
  - **การจัดหมวดหมู่:** มีการจัดหมวดหมู่รูปภาพอย่างเป็นระบบผ่านตาราง **`media_category`** และ **`media_tags`** (พร้อมตารางเชื่อมโยงเพื่อรองรับความสัมพันธ์แบบ Many-to-Many) ซึ่งช่วยอำนวยความสะดวกในการค้นหา การจัดระเบียบ และการนำรูปภาพกลับมาใช้ซ้ำในโมดูลต่างๆ เช่น การค้นหารูปภาพที่เกี่ยวข้องกับ "พริกไทยดำ" หรือ "วัตถุดิบทำอาหาร"
- **Backend (Route Handlers \+ Services):**
  - **การอัปโหลด:** ในส่วนของการอัปโหลด จะรองรับการรับไฟล์รูปภาพแบบ multipart/form-data ซึ่งเป็นมาตรฐานสำหรับการส่งไฟล์ผ่าน HTTP Request โดยมีการตรวจสอบประเภทและขนาดของไฟล์เบื้องต้นเพื่อความปลอดภัย
  - **การประมวลผลภาพ:** สำหรับการประมวลผลภาพ จะมีการใช้ Library เช่น **`sharp`** ใน Backend เพื่อดำเนินการสร้างรูปภาพในขนาดที่หลากหลาย (variants) โดยอัตโนมัติภายหลังกระบวนการอัปโหลดเสร็จสิ้น `sharp` มีความสามารถในการบีบอัดภาพเพื่อลดขนาดไฟล์ การแปลงรูปแบบไฟล์ (เช่นจาก PNG เป็น WebP) และการจัดการภาพขั้นสูงอื่นๆ ซึ่งช่วยเพิ่มประสิทธิภาพการโหลดหน้าเว็บและปรับปรุงประสบการณ์ผู้ใช้โดยรวม
  - **ที่เก็บไฟล์:** การจัดเก็บไฟล์รูปภาพแนะนำให้ใช้บริการ **Cloud Storage** (อาทิ AWS S3, Google Cloud Storage, Cloudinary) ซึ่งเป็นแนวทางที่เหมาะสมสำหรับ Production Environment เนื่องจากมอบความสามารถในการปรับขนาด (Scalability) เพื่อรองรับการเติบโตของปริมาณข้อมูล ความทนทานของข้อมูล (Durability) สูง และการเข้าถึงข้อมูลทั่วโลกได้อย่างมีประสิทธิภาพผ่านการผสานรวมกับ Content Delivery Networks (CDNs)
  - **API:** มีการจัดเตรียม API สำหรับการจัดการรูปภาพ ซึ่งครอบคลุมการดำเนินการที่สำคัญ ได้แก่ การอัปโหลด การลบ การแก้ไข Metadata (อาทิ Alt Text และคำบรรยายภาพ) รวมถึงการค้นหาและกรองรูปภาพตาม Tag หรือ Category เพื่อให้ Frontend สามารถโต้ตอบกับ Media Library ได้อย่างสมบูรณ์และผู้ดูแลระบบสามารถจัดการ Asset ได้อย่างมีประสิทธิภาพ
- **Frontend (Admin UI):**
  - **Media Uploader Component:** ใน Admin UI จะมีส่วนประกอบ Media Uploader Component ที่รองรับการอัปโหลดรูปภาพพร้อมช่องสำหรับกรอก Alt Text และคำบรรยายภาพในหลายภาษา เพื่อให้ผู้ดูแลระบบสามารถระบุข้อมูลที่จำเป็นสำหรับการทำ SEO และการเข้าถึง (accessibility) ของเว็บไซต์ได้อย่างครบถ้วน
  - **Media Library:** Media Library จะทำหน้าที่เป็นหน้าจอหลักสำหรับแสดงผลรูปภาพทั้งหมดในระบบ พร้อมฟังก์ชันการค้นหา การกรอง (ตามหมวดหมู่, Tag) และการเลือกรูปภาพเพื่อนำไปใช้ในส่วนต่างๆ ของระบบ เช่น การเชื่อมโยงกับข้อมูลสินค้าหรือบทความ ช่วยให้การจัดการ Asset เป็นไปอย่างคล่องตัว

## 6. ระบบยืนยันตัวตนและกำหนดสิทธิ์ (Authentication & Authorization)

ระบบนี้มีโครงสร้างที่แข็งแกร่งสำหรับการจัดการผู้ใช้งานและการควบคุมการเข้าถึง

### 6.1 ชั้นยืนยันตัวตน (Authentication)

- ใช้ **NextAuth.js** ซึ่งรองรับการล็อกอินแบบ credential (เช่น อีเมล/รหัสผ่าน) และการจัดการ session แบบ JWT (JSON Web Tokens) ซึ่งเป็นวิธีที่ปลอดภัยและ Scalable
- ระหว่าง session จะมีการฝังข้อมูลบทบาทและสิทธิ์ของผู้ใช้งาน (role and permissions) ลงใน JWT หรือ Session Object เพื่อให้สามารถเข้าถึงข้อมูลการอนุญาตได้อย่างรวดเร็วในทุก Request โดยไม่จำเป็นต้อง Query ฐานข้อมูลซ้ำ
-

### 6.2 กรอบการกำหนดสิทธิ์ (Authorization)

ใช้โครงสร้าง **Role-Based Access Control (RBAC)** เพื่อควบคุมสิทธิ์ตามบทบาทของผู้ใช้งาน โดยมีการแยกตาราง `User`, `Role`, `Permission`, และ `RolePermission` อย่างชัดเจน เพื่อให้ระบบมีความยืดหยุ่นสูงสุดในการกำหนดและปรับเปลี่ยนสิทธิ์โดยไม่ต้องแก้ไขโค้ด Logic โดยตรง

```tsx
// Revised Prisma Schema for RBAC (as per discussions)
// This schema uses a dynamic approach for Role names and Permission actions/resources
// to allow management via Admin UI without code changes for new entries.

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  emailVerifiedAt DateTime?
  name            String?
  passwordHash    String?
  image           String?

  isActive        Boolean   @default(true) // Indicates if the user account is active/suspended
  preferredLanguage String? // User's preferred UI language (e.g., "en", "th")

  roleId          String?
  role            Role?     @relation(fields: [roleId], references: [id])

  accounts        Account[]
  sessions        Session[]

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([roleId])
}

model Role {
  id          String         @id @default(uuid()) // Using uuid() for consistency with design document
  key         String         @unique // Technical identifier, e.g., "admin", "editor", "viewer"
  name        String         // Display name, can be translated. No longer @unique to allow dynamic updates.
  description String?        @db.Text // Optional: Description of the role (can be long)
  isSystem    Boolean        @default(false) // True if system-defined role (not deletable/editable via UI)

  users       User[]
  permissions RolePermission[]

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}

model Permission {
  id          String         @id @default(uuid()) // Using uuid() for consistency with design document
  key         String         @unique // Technical identifier, e.g., "product:create", "user:read"
  action      String         // Action part of permission (e.g., "CREATE", "READ", "UPDATE", "DELETE"). String for dynamic management.
  resource    String         // Resource part of permission (e.g., "PRODUCT", "POST", "USER"). String for dynamic management.
  description String?        @db.Text // Optional: Description of the permission (can be long)
  isSystem    Boolean        @default(false) // True if system-defined permission

  roles       RolePermission[]

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@unique([action, resource]) // Ensures unique combination of action and resource
}

model RolePermission {
  id           String     @id @default(uuid()) // Using uuid() for consistency with design document
  roleId       String
  permissionId String

  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([roleId, permissionId]) // Ensures unique role-permission pair
}
```

- **ตัวอย่างบทบาทที่ใช้:**
  - `superadmin`: เข้าถึงทุกฟีเจอร์โดยไม่มีข้อจำกัด ซึ่งอาจจะมีการตรวจสอบสิทธิ์พิเศษใน Application Logic
  - `editor`: จัดการเฉพาะเนื้อหาและสื่อภาพ (เช่น `post.create`, `post.update`, `media.upload`, `media.read`)
  - `product_manager`: จัดการเฉพาะข้อมูลสินค้า (เช่น `product.create`, `product.update`, `product.delete`)
- การออกแบบนี้ช่วยให้สามารถเพิ่มบทบาทหรือสิทธิ์ใหม่ๆ ได้โดยการอัปเดตข้อมูลในฐานข้อมูล ไม่ใช่การแก้ไขโค้ด ซึ่งเป็นการส่งเสริมความยืดหยุ่นในการบริหารจัดการระบบอย่างแท้จริง

## 7. สถาปัตยกรรมเชิงโมดูลของเนื้อหา

ระบบได้รับการออกแบบให้เป็นแบบ Modular เพื่อความยืดหยุ่นในการจัดการเนื้อหาแต่ละประเภท

| โมดูล            | คำอธิบาย                   | หมายเหตุ                                 |
| ---------------- | -------------------------- | ---------------------------------------- |
| Product          | แคตตาล็อกสินค้าแบบหลายภาษา | มีราคาสินค้า ภาพหลัก และแกลเลอรี่        |
| Category         | ระบบหมวดหมู่สินค้า         | รองรับการจัดเรียงแบบชั้นเดียวหรือซ้อนกัน |
| Post             | เนื้อหาบทความหรือบล็อก     | รองรับ editor และแปลหลายภาษา             |
| Media            | คลังภาพส่วนกลาง            | ใช้ซ้ำได้กับทุกโมดูล                     |
| User / Role      | สิทธิ์ผู้ใช้ในระบบ         | จัดการบทบาทและการเข้าถึง                 |
| Page (ไม่บังคับ) | หน้าคงที่แบบเนื้อหา        | เช่น หน้าเกี่ยวกับเรา หรือ ติดต่อเรา     |

แต่ละโมดูลจะมีการแยก Service Layer, API Endpoints, และ Admin UI Components ของตนเองอย่างชัดเจน ซึ่งเป็นการกำหนด Boundary ของแต่ละส่วนย่อย ทำให้การพัฒนา บำรุงรักษา และการนำกลับมาใช้ซ้ำเป็นไปได้ง่ายขึ้น

## 8. การจัดการฟอร์ม (Form Handling)

- **Stack:** ใช้ **`react-hook-form`** ร่วมกับ **`zod`** และ **`@hookform/resolvers/zod`** เพื่อสร้างฟอร์มที่มี Type Safety และมีการ Validation ทั้งในฝั่ง Client และ Server
- **หลักการ:** กฎการตรวจสอบความถูกต้องของข้อมูลทั้งหมด (Validation Logic) จะถูกกำหนดไว้ที่ Zod Schema ใน `src/lib/schemas/` เท่านั้น เพื่อให้เป็น Single Source of Truth สำหรับทั้งระบบ
- **ดูรายละเอียดเพิ่มเติมได้ที่:** `docs/guides/forms.md`

## 9. รูปแบบเส้นทาง (Routing)

การกำหนดรูปแบบเส้นทาง (Routing) ที่ชัดเจนเป็นสิ่งสำคัญสำหรับทั้งผู้ใช้งานทั่วไปและผู้ดูแลระบบ:

| เส้นทาง                     | หน้าที่                                         |
| --------------------------- | ----------------------------------------------- |
| `/[locale]/products`        | แสดงรายการสินค้าในภาษานั้น ๆ                    |
| `/[locale]/products/[slug]` | แสดงรายละเอียดสินค้า                            |
| `/[locale]/blog`            | แสดงบทความทั้งหมด                               |
| `/[locale]/blog/[slug]`     | แสดงรายละเอียดบทความ                            |
| `/[locale]/admin/*`         | เข้าสู่แดชบอร์ดหลังบ้าน (ควบคุมสิทธิ์ด้วย RBAC) |

รูปแบบเส้นทางนี้รองรับการทำ Internationalized Routing และยังมีการแยกเส้นทางสำหรับผู้ดูแลระบบอย่างชัดเจน เพื่อให้สามารถบังคับใช้มาตรการรักษาความปลอดภัยและการควบคุมสิทธิ์ได้อย่างเหมาะสม

## 10. การขยายระบบในอนาคต

สถาปัตยกรรมที่ออกแบบมานี้รองรับการขยายขีดความสามารถในอนาคตได้อย่างยืดหยุ่น:

- เพิ่มระบบลงทะเบียนและจัดการ session ของผู้ใช้งานทั่วไป เพื่อรองรับ User-facing Features ในอนาคต
- ขยายระบบให้รองรับการสั่งซื้อ เช่น ตะกร้าสินค้า รายการโปรด ซึ่งจะต่อยอดจากโมดูล Product ที่มีอยู่แล้ว
- เพิ่มระบบค้นหาแบบ Full-text โดยใช้ PostgreSQL, Meilisearch หรือ ElasticSearch เพื่อให้การค้นหาเนื้อหาและสินค้ามีประสิทธิภาพและรวดเร็วยิ่งขึ้น
- เพิ่มความสามารถในการเปลี่ยนธีมหรือโครงร่างหน้าเว็บด้วยการตั้งค่าแบบ dynamic ซึ่งจะช่วยให้ระบบสามารถปรับแต่งหน้าตาได้โดยไม่ต้องแก้ไขโค้ดโดยตรง

เอกสารฉบับนี้ถือเป็นรากฐานสำคัญในการพัฒนาแพลตฟอร์ม CMS หลายภาษาที่สามารถปรับขยายได้ในระดับองค์กร และเหมาะสมสำหรับการนำไปประยุกต์ใช้ในระบบอื่นในอนาคต โดยเน้นการออกแบบที่คำนึงถึง Abstraction และ Boundary ของแต่ละ Layer อย่างรอบคอบ
